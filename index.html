<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Microondas Timer OCR</title>
  <script src="libs/tesseract/tesseract.min.js"></script>
  <style>
    body { margin:0; font-family: system-ui; background: #111; color: #fff; text-align: center; }
    #videoWrapper { position: relative; width: 100%; max-width: 500px; margin: 20px auto; }
    #video { width: 100%; border: 4px solid #00ff00; border-radius: 16px; display: block; }
    #roiOverlay { position: absolute; border: 3px dashed rgba(0, 255, 0, 0.7); border-radius: 12px; pointer-events: none; transition: all 0.2s ease; }
    #scanningBadge { position: absolute; top: 16px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.65); color: #0f0; padding: 6px 16px; border-radius: 999px; font-size: 0.95rem; letter-spacing: 0.05em; backdrop-filter: blur(6px); display: flex; align-items: center; gap: 8px; transition: opacity 0.2s ease; }
    #scanningBadge.hidden { opacity: 0; pointer-events: none; }
    #scanningBadge::before { content: "‚óè"; font-size: 0.8rem; animation: pulse 1.4s infinite; }
    @keyframes pulse { 0% { opacity: 0.2; } 50% { opacity: 1; } 100% { opacity: 0.2; } }
    #feedbackOverlay { position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 16px; background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(4px); border-radius: 16px; padding: 20px; transition: opacity 0.2s ease; }
    #feedbackOverlay.hidden { opacity: 0; pointer-events: none; }
    #feedbackText { font-size: 1.8rem; font-weight: 600; letter-spacing: 0.08em; color: #0f0; text-shadow: 0 0 12px rgba(0, 255, 0, 0.6); }
    #feedbackActions { display: flex; gap: 16px; flex-wrap: wrap; justify-content: center; }
    #feedbackActions button { background: rgba(0, 0, 0, 0.8); border: 2px solid #0f0; color: #0f0; padding: 12px 20px; border-radius: 28px; font-size: 1rem; cursor: pointer; }
    #feedbackActions button.confirm { background: #0f0; color: #111; border-color: #0f0; }
    #feedbackActions button:active { transform: scale(0.96); }
    #canvas { display: none; }
    #timer { font-size: 4rem; margin: 20px; display: flex; align-items: center; justify-content: center; min-height: 120px; }
    #timer.ready { font-size: 5rem; }
    #timer span { display: inline-block; }
    button { padding: 14px 28px; font-size: 1.1rem; background: #00ff00; border: none; border-radius: 36px; margin: 10px; cursor: pointer; transition: transform 0.2s ease; }
    button:active { transform: scale(0.97); }
    .hidden { display: none; }
    #status { font-size: 1.2rem; color: #0f0; margin-top: 10px; }
    #manualControls { margin-top: 24px; }
    #manualControls h2 { margin-bottom: 8px; font-size: 1.4rem; }
    .manual-row { display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 12px; flex-wrap: wrap; }
    label { font-size: 0.9rem; text-transform: uppercase; letter-spacing: 0.06em; color: #0f0; }
    input[type="number"] { width: 80px; padding: 10px; border-radius: 16px; border: 2px solid #0f0; background: #111; color: #fff; font-size: 1.3rem; text-align: center; }
    .manual-sep { font-size: 1.6rem; }
  </style>
</head>
<body>
  <h1>üìü Microondas Timer OCR</h1>
  <p>Aponta pro visor do micro-ondas!</p>
  <div id="videoWrapper">
    <video id="video" playsinline></video>
    <div id="roiOverlay" aria-hidden="true"></div>
    <div id="scanningBadge" class="hidden">Analisando visor...</div>
    <div id="feedbackOverlay" class="hidden">
      <div id="feedbackText">--:--</div>
      <div id="feedbackActions">
        <button id="feedbackConfirm" class="confirm">‚úÖ Confirmar</button>
        <button id="feedbackRetry">‚Ü∫ Ajustar leitura</button>
      </div>
    </div>
  </div>
  <canvas id="canvas"></canvas>
  <div id="timer"><span id="timerText">00:00</span></div>
  <button id="startBtn">üé• Ativar C√¢mera</button>
  <button id="stopBtn" class="hidden">‚èπ Parar</button>
  <button id="resetBtn">üîÅ Resetar</button>
  <div id="manualControls">
    <h2>Timer Manual</h2>
    <div class="manual-row">
      <input id="manualMinutes" type="number" min="0" max="59" value="0" aria-label="Minutos">
      <span class="manual-sep">:</span>
      <input id="manualSeconds" type="number" min="0" max="59" value="30" aria-label="Segundos">
    </div>
    <button id="manualStartBtn">‚ñ∂Ô∏è Iniciar Manual</button>
    <h2>√Årea do visor (%)</h2>
    <div class="manual-row">
      <label for="roiTop">Topo</label>
      <input id="roiTop" type="number" min="0" max="95" value="10">
      <label for="roiLeft">Esq</label>
      <input id="roiLeft" type="number" min="0" max="95" value="55">
    </div>
    <div class="manual-row">
      <label for="roiWidth">Largura</label>
      <input id="roiWidth" type="number" min="5" max="100" value="35">
      <label for="roiHeight">Altura</label>
      <input id="roiHeight" type="number" min="5" max="100" value="35">
    </div>
  </div>
  <div id="status">Toque em Ativar C√¢mera</div>

  <script>
    const video = document.getElementById('video');
    const roiOverlay = document.getElementById('roiOverlay');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const timerDisplay = document.getElementById('timer');
    const timerText = document.getElementById('timerText');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const manualMinutes = document.getElementById('manualMinutes');
    const manualSeconds = document.getElementById('manualSeconds');
    const manualStartBtn = document.getElementById('manualStartBtn');
    const roiTopInput = document.getElementById('roiTop');
    const roiLeftInput = document.getElementById('roiLeft');
    const roiWidthInput = document.getElementById('roiWidth');
    const roiHeightInput = document.getElementById('roiHeight');
    const scanningBadge = document.getElementById('scanningBadge');
    const feedbackOverlay = document.getElementById('feedbackOverlay');
    const feedbackText = document.getElementById('feedbackText');
    const feedbackConfirm = document.getElementById('feedbackConfirm');
    const feedbackRetry = document.getElementById('feedbackRetry');
    const status = document.getElementById('status');

    let stream = null;
    let timerInterval = null;
    let secondsLeft = 0;
    let worker = null;
    let ocrInterval = null;
    let isProcessingFrame = false;
    let alarmTimeout = null;
    let beepInterval = null;
    let audioUnlocked = false;
    let pendingDetection = null;
    let isConfirmingDetection = false;
    let lastPreviewSeconds = null;
    const roi = { top: 10, left: 55, width: 35, height: 35 };
    const recognitionBuffer = [];
    const RECOGNITION_BUFFER_SIZE = 5;
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioContextClass ? new AudioContextClass() : null;
    const alarmAudio = new Audio("https://assets.mixkit.co/sfx/preview/mixkit-alarm-digital-clock-beep-989.mp3");
    alarmAudio.loop = true;

    async function ensureAudioUnlocked() {
      if (audioUnlocked) return;
      try {
        await alarmAudio.play();
        alarmAudio.pause();
        alarmAudio.currentTime = 0;
        audioUnlocked = true;
      } catch (_) {
        // browsers podem bloquear at√© pr√≥ximo gesto
      }
      if (audioCtx && audioCtx.state === "suspended") {
        try {
          await audioCtx.resume();
        } catch (_) {}
      }
    }

    function scheduleBeepPattern() {
      if (!audioCtx) return;
      const now = audioCtx.currentTime + 0.05;
      const createBeep = (startTime) => {
        const oscillator = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        oscillator.type = "square";
        oscillator.frequency.value = 880;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.4, startTime + 0.05);
        gain.gain.linearRampToValueAtTime(0, startTime + 0.45);
        oscillator.connect(gain).connect(audioCtx.destination);
        oscillator.start(startTime);
        oscillator.stop(startTime + 0.5);
      };

      for (let i = 0; i < 3; i++) {
        createBeep(now + i * 0.6);
      }
    }

    async function stopCamera({ resetTimer = true, message } = {}) {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      if (worker) {
        await worker.terminate();
        worker = null;
      }
      if (ocrInterval) {
        clearInterval(ocrInterval);
        ocrInterval = null;
      }
      clearInterval(timerInterval);
      resetDetectionState();
      hideScanningMessage();
      isProcessingFrame = false;
      stopAlarm();
      video.srcObject = null;
      startBtn.classList.remove('hidden');
      stopBtn.classList.add('hidden');
      timerDisplay.classList.remove('ready');
      if (resetTimer) {
        secondsLeft = 0;
        timerText.textContent = "00:00";
      }
      if (message !== undefined) {
        status.textContent = message;
      }
    }

    function updateTimerDisplay() {
      const m = Math.floor(secondsLeft / 60);
      const s = secondsLeft % 60;
      timerDisplay.classList.remove('ready');
      timerText.textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    // Iniciar c√¢mera
    startBtn.onclick = async () => {
      await ensureAudioUnlocked();
      alarmAudio.load();

      stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
      video.srcObject = stream;
      video.play();
      resetDetectionState();
      showScanningMessage("Analisando visor...");
      applyRoiStyles();
      secondsLeft = 0;
      timerDisplay.classList.remove('ready');
      timerText.textContent = "00:00";
      startBtn.classList.add('hidden');
      stopBtn.classList.remove('hidden');
      status.textContent = "Lendo visor...";
      startOCR();
    };

    stopBtn.onclick = async () => {
      await stopCamera({ message: "Parado" });
    };

    resetBtn.onclick = async () => {
      await ensureAudioUnlocked();
      await stopCamera({ message: "Timer resetado" });
    };

    const clamp = (value, max) => {
      const num = Number.parseInt(value, 10);
      if (Number.isNaN(num) || num < 0) return 0;
      return Math.min(num, max);
    };

    const clampRange = (value, min, max, fallback) => {
      const num = Number.parseFloat(value);
      if (Number.isNaN(num)) return fallback;
      return Math.min(Math.max(num, min), max);
    };

    function normalizeRoi() {
      roi.width = Math.min(Math.max(roi.width, 5), 100);
      roi.height = Math.min(Math.max(roi.height, 5), 100);
      if (roi.left + roi.width > 100) {
        roi.left = Math.max(0, 100 - roi.width);
      }
      if (roi.top + roi.height > 100) {
        roi.top = Math.max(0, 100 - roi.height);
      }
      roi.left = Math.max(0, Math.min(roi.left, 100 - roi.width));
      roi.top = Math.max(0, Math.min(roi.top, 100 - roi.height));
    }

    function applyRoiStyles() {
      normalizeRoi();
      roiOverlay.style.top = `${roi.top}%`;
      roiOverlay.style.left = `${roi.left}%`;
      roiOverlay.style.width = `${roi.width}%`;
      roiOverlay.style.height = `${roi.height}%`;
      roiTopInput.value = Math.round(roi.top);
      roiLeftInput.value = Math.round(roi.left);
      roiWidthInput.value = Math.round(roi.width);
      roiHeightInput.value = Math.round(roi.height);
    }

    function updateRoiFromInputs() {
      roi.top = clampRange(roiTopInput.value, 0, 95, roi.top);
      roi.left = clampRange(roiLeftInput.value, 0, 95, roi.left);
      roi.width = clampRange(roiWidthInput.value, 5, 100, roi.width);
      roi.height = clampRange(roiHeightInput.value, 5, 100, roi.height);
      if (roi.width + roi.left > 100) {
        roi.left = 100 - roi.width;
      }
      if (roi.height + roi.top > 100) {
        roi.top = 100 - roi.height;
      }
      applyRoiStyles();
    }

    [roiTopInput, roiLeftInput, roiWidthInput, roiHeightInput].forEach(input => {
      if (!input) return;
      input.addEventListener('change', updateRoiFromInputs);
      input.addEventListener('input', updateRoiFromInputs);
    });

    applyRoiStyles();

    function formatSeconds(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = totalSeconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function showScanningMessage(message) {
      if (!scanningBadge) return;
      scanningBadge.textContent = message;
      scanningBadge.classList.remove('hidden');
    }

    function hideScanningMessage() {
      if (!scanningBadge) return;
      scanningBadge.classList.add('hidden');
    }

    function updateScanningPreview(totalSeconds) {
      if (isConfirmingDetection) return;
      if (!scanningBadge) return;
      if (!Number.isFinite(totalSeconds) || totalSeconds <= 0) {
        lastPreviewSeconds = null;
        showScanningMessage("Analisando visor...");
        return;
      }
      if (totalSeconds === lastPreviewSeconds) return;
      lastPreviewSeconds = totalSeconds;
      showScanningMessage(`Pr√©via: ${formatSeconds(totalSeconds)}`);
    }

    function showDetectionPrompt(totalSeconds) {
      if (!feedbackOverlay) return;
      pendingDetection = totalSeconds;
      isConfirmingDetection = true;
      recognitionBuffer.length = 0;
      const formatted = formatSeconds(totalSeconds);
      if (feedbackText) {
        feedbackText.textContent = `Tempo detectado: ${formatted}`;
      }
      feedbackOverlay.classList.remove('hidden');
      hideScanningMessage();
      status.textContent = `Confirme a leitura ${formatted}.`;
    }

    function hideDetectionPrompt() {
      if (!feedbackOverlay) return;
      feedbackOverlay.classList.add('hidden');
    }

    function resetDetectionState() {
      recognitionBuffer.length = 0;
      pendingDetection = null;
      isConfirmingDetection = false;
      lastPreviewSeconds = null;
      hideDetectionPrompt();
    }

    manualMinutes.addEventListener('change', () => {
      manualMinutes.value = clamp(manualMinutes.value, 59);
    });
    manualSeconds.addEventListener('change', () => {
      manualSeconds.value = clamp(manualSeconds.value, 59);
    });

    manualStartBtn.onclick = async () => {
      await ensureAudioUnlocked();
      const mins = clamp(manualMinutes.value, 59);
      const secs = clamp(manualSeconds.value, 59);
      manualMinutes.value = mins;
      manualSeconds.value = secs;
      const totalSeconds = mins * 60 + secs;
      if (totalSeconds <= 0) {
        status.textContent = "Informe um tempo manual v√°lido.";
        return;
      }

      await stopCamera({ resetTimer: false });
      secondsLeft = totalSeconds;
      updateTimerDisplay();
      startTimer();
      status.textContent = `Timer manual: ${mins}:${secs.toString().padStart(2,'0')}`;
    };

    if (feedbackConfirm) {
      feedbackConfirm.addEventListener('click', async () => {
        if (pendingDetection === null) return;
        const confirmedSeconds = pendingDetection;
        await ensureAudioUnlocked();
        await stopCamera({ resetTimer: false });
        secondsLeft = confirmedSeconds;
        updateTimerDisplay();
        startTimer();
        status.textContent = `Timer confirmado: ${formatSeconds(confirmedSeconds)}`;
      });
    }

    if (feedbackRetry) {
      feedbackRetry.addEventListener('click', () => {
        resetDetectionState();
        showScanningMessage("Reposicione e mantenha o visor est√°vel...");
        status.textContent = "Ajuste o enquadramento e aguarde nova leitura.";
      });
    }

    // OCR com Tesseract
    async function startOCR() {
      if (worker) {
        await worker.terminate();
      }

      resetDetectionState();
      showScanningMessage("Analisando visor...");
      worker = await Tesseract.createWorker(['eng'], {
        workerPath: 'libs/tesseract/worker.min.js',
        corePath: 'libs/tesseract/tesseract-core.wasm.js',
        langPath: 'libs/tesseract/lang/',
        cachePath: 'libs/tesseract/lang/'
      });

      await worker.load();
      await worker.loadLanguage('eng');
      await worker.initialize('eng');
      await worker.setParameters({
        tessedit_char_whitelist: '0123456789:.',
      });

      if (ocrInterval) clearInterval(ocrInterval);

      ocrInterval = setInterval(async () => {
        if (!video.videoWidth || !video.videoHeight) return;
        if (isProcessingFrame) return;
        if (isConfirmingDetection) return;

        const sx = Math.floor(video.videoWidth * (roi.left / 100));
        const sy = Math.floor(video.videoHeight * (roi.top / 100));
        const sw = Math.floor(video.videoWidth * (roi.width / 100));
        const sh = Math.floor(video.videoHeight * (roi.height / 100));

        if (sw < 10 || sh < 10) {
          return;
        }

        isProcessingFrame = true;

        try {
          if ('createImageBitmap' in window) {
            const frame = await createImageBitmap(video, sx, sy, sw, sh);
            canvas.width = frame.width;
            canvas.height = frame.height;
            ctx.drawImage(frame, 0, 0);
            frame.close();
          } else {
            canvas.width = sw;
            canvas.height = sh;
            ctx.drawImage(video, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);
          }

          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const processed = preprocessFrame(imageData);
          ctx.putImageData(processed, 0, 0);

          const result = await worker.recognize(canvas);
          const rawText = result.data.text || '';
          const totalSeconds = parseTimerText(rawText);

          if (totalSeconds > 0 && totalSeconds < 3600) { // m√°ximo 1h
            updateScanningPreview(totalSeconds);
            handleRecognition(totalSeconds);
          } else {
            updateScanningPreview(null);
          }
        } finally {
          isProcessingFrame = false;
        }
      }, 1500); // ~1.5s
    }

    // Timer
    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (secondsLeft <= 0) {
          clearInterval(timerInterval);
          timerDisplay.classList.add('ready');
          timerText.textContent = "üçΩÔ∏è";
          status.textContent = "Tempo esgotado!";
          playAlarm();
          return;
        }
        secondsLeft--;
        updateTimerDisplay();
      }, 1000);
      updateTimerDisplay();
    }

    // Alarme + vibra√ß√£o + notifica√ß√£o
    function playAlarm() {
      stopAlarm();
      ensureAudioUnlocked();
      alarmAudio.currentTime = 0;
      alarmAudio.play().catch(() => {});
      scheduleBeepPattern();
      beepInterval = setInterval(scheduleBeepPattern, 2000);
      
      // Vibrar (s√≥ Android)
      if (navigator.vibrate) {
        navigator.vibrate([1000, 500, 1000, 500, 1000]);
      }

      // Notifica√ß√£o (permiss√£o)
      if (Notification.permission === "granted") {
        new Notification("Microondas acabou!", { body: "Corre antes que queime!", icon: "https://cdn-icons-png.flaticon.com/512/2303/2303043.png" });
      } else if (Notification.permission !== "denied") {
        Notification.requestPermission();
      }

      alarmTimeout = setTimeout(() => alarmAudio.pause(), 30000); // para ap√≥s 30s
    }

    function parseTimerText(rawText) {
      const cleaned = rawText.replace(/\s+/g, '');
      if (!cleaned) return 0;

      let mins = 0;
      let secs = 0;

      const colonMatch = cleaned.match(/(\d{1,2})[:.](\d{2})/);

      if (colonMatch) {
        mins = parseInt(colonMatch[1], 10) || 0;
        secs = parseInt(colonMatch[2], 10) || 0;
      } else {
        const digitsOnly = cleaned.replace(/\D/g, '');
        if (digitsOnly.length >= 2) {
          if (digitsOnly.length >= 4) {
            const trimmed = digitsOnly.slice(-4);
            mins = parseInt(trimmed.slice(0, -2), 10) || 0;
            secs = parseInt(trimmed.slice(-2), 10) || 0;
          } else if (digitsOnly.length === 3) {
            mins = parseInt(digitsOnly.slice(0, 1), 10) || 0;
            secs = parseInt(digitsOnly.slice(1), 10) || 0;
          } else {
            secs = parseInt(digitsOnly, 10) || 0;
          }
        }
      }

      if (secs >= 60) {
        mins += Math.floor(secs / 60);
        secs = secs % 60;
      }

      return mins * 60 + secs;
    }

    function handleRecognition(totalSeconds) {
      if (isConfirmingDetection) return;
      recognitionBuffer.push(totalSeconds);
      if (recognitionBuffer.length > RECOGNITION_BUFFER_SIZE) {
        recognitionBuffer.shift();
      }

      const tally = recognitionBuffer.reduce((acc, value) => {
        acc.set(value, (acc.get(value) || 0) + 1);
        return acc;
      }, new Map());

      let bestValue = null;
      let bestCount = 0;
      tally.forEach((count, value) => {
        if (count > bestCount) {
          bestValue = value;
          bestCount = count;
        }
      });

      const required = Math.ceil(Math.min(recognitionBuffer.length, RECOGNITION_BUFFER_SIZE) / 2);

      if (bestValue !== null && bestCount >= required) {
        showDetectionPrompt(bestValue);
      }
    }

    function preprocessFrame(imageData) {
      const data = imageData.data;
      const contrastFactor = 1.6;
      for (let i = 0; i < data.length; i += 4) {
        const gray = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
        const contrasted = Math.max(0, Math.min(255, (gray - 128) * contrastFactor + 128));
        const value = contrasted < 110 ? 0 : contrasted > 220 ? 255 : contrasted;
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
      return imageData;
    }

    function stopAlarm() {
      alarmAudio.pause();
      alarmAudio.currentTime = 0;
      if (alarmTimeout) {
        clearTimeout(alarmTimeout);
        alarmTimeout = null;
      }
      if (beepInterval) {
        clearInterval(beepInterval);
        beepInterval = null;
      }
      if (navigator.vibrate) {
        navigator.vibrate(0);
      }
    }
  </script>
</body>
</html>